# Day 4
### Longest Palindromic Substring
经典的算法，填充辅助字符，使得奇偶回文串统一变成奇数回文串的情况，方便处理。
但是效率比较低，28ms，只超过了51%的人。

基于笨算法，我觉得可以通过目前最长的长度来优化：
1. 如果当前不可能达到这么长的，直接不用去尝试扩展回文串了；（比如边界的位置）
2. 先从当前最长的长度往中间回溯，可以挡掉很多短的回文串；（比如cdbabcd，从边界就知道它不可能是一个半径长度超过4的回文串）

优化的结果是12ms，很不错。

最后学习了Manacher算法，这个算法其实很简洁易懂啦，评测结果是8ms，棒棒的，然而也只是超过了85%的人。这个我分析应该是扩展字符串那里的性能浪费的问题！有空可以再研究一下。


# Day 3
### ZigZag Conversion
一开始算法没考虑清晰，而且还忽略了边界情况（numRows=1时会退化）。先设计好算法，证明好正确性，再开始写代码。

### Median of Two Sorted Arrays
算法还是比较容易想的，不过效率只超过66%的人？都已经是线性的了，还能优化吗？
目前能想到的就是如果其中一个数组为空，另一个数组的中位数可以O(1)时空复杂度来得到！


# Day 2
### Longest Substring Without Repeating Characters
最长不出现重复字母的子串，算法很简单，可以暴力从每个index开始都查找一遍这个子串（这是O(N^2)的复杂度），也可以打表，用前面已经打过的表来减少查找复杂度，每个下标最多会被访问一次，整体复杂度为O(N)。


# Day 1
### Two Sum
忽略了关键条件：同一个元素最多只能用一次

### Add Two Numbers
忽略了1 + 99 = 100这种最终会进位的情况，单纯模拟了按位加法，没有彻底清晰的算法流程意识。

